<?php

class UserGroupsHooks extends WireData implements Module {

	/**
	 * @var Page Special group "Everyone"
	 */
	private $groupEveryone;
	/**
	 * @var Page Special group "Logged in users"
	 */
	private $groupLoggedIn;

	/**
	 * getModuleInfo is a module required by all modules to tell ProcessWire about them
	 *
	 * @return array
	 *
	 */
	public static function getModuleInfo() {

		return array(
			'title' => 'User Groups Hooks',
			'version' => 1,
			'summary' => 'Autoload module that attachs all the hooks required by User Groups.',
			'singular' => true,
			'autoload' => true,
			'requires' => 'ProcessUserGroups'
		);
	}

	/**
	 * Initialize the module
	 *
	 * ProcessWire calls this when the module is loaded. For 'autoload' modules, this will be called
	 * when ProcessWire's API is ready. As a result, this is a good place to attach hooks.
	 *
	 */
	public function init() {

		// Add $groups API variable
		$template = $this->templates->get('user-group');
		$parent = $this->pages->get("template=admin, name=usergroups");
		$groups = new PagesType($template, $parent->id);
		Wire::setFuel('groups', $groups);

		// fetch special groups for later use (find(), viewable())
		$this->groupEveryone = wire('groups')->get("everyone");
		$this->groupLoggedIn = wire('groups')->get("logged");

		// user is always a member of "Everyone"
		// logged in status is handled case by case as that may change (at least in theory)
		wire('user')->user_groups->add($this->groupEveryone);

		// hooks (see function declarations for more information)
		$this->addHookAfter("ProcessPageEdit::buildFormRoles", $this, 'whoCanAccessInfo');
		$this->addHookAfter("Page::viewable", $this, 'viewable');
		$this->addHookAfter("Page::editable", $this, 'editable');
		$this->addHookAfter("Page::addable", $this, 'addable');
		$this->addHookAfter("Page::moveable", $this, 'moveable');
		$this->addHookAfter("Page::sortable", $this, 'sortable');
		$this->addHookBefore("Pages::find", $this, 'find');
		$this->addHookAfter("Pages::saveReady", $this, 'save');
		$this->addHookAfter("Pages::moved", $this, 'moved');
		$this->addHookAfter("Pages::trashed", $this, 'trashed');
		$this->addHookAfter("Pages::added", $this, 'added');
		$this->addHookBefore("ProcessPageAdd::getAllowedTemplates", $this, 'allowedTemplates');

	}

	/**
	 * Page trashed, clean up inheritance information
	 *
	 * Also save() and moved() get called but they short circuit for trashed pages.
	 * Restoring pages requires no special care as moved() handles that also.
	 * Deleting pages (trashed or not) requires no special care as core cleans up refs to deleted pages automagically.
	 *
	 */
	public function trashed($event) {

		$page = $event->arguments[0];

		$this->log->message("trashed: $page->id @ $page->path");

		$deletions = array($page->id);
		foreach($this->pages->find("has_parent=$page, include=all") as $p) $deletions[] = $p->id;

		if (count($deletions)) {
			$sql = "DELETE FROM field_inherit_access WHERE pages_id IN(" . implode(',', $deletions) . ")";
			$this->log->message($sql);
			$this->db->query($sql);
		}
	}

	/**
	 * Page added, rebuild for the new page.
	 *
	 */
	public function added($event) {

		$page = $event->arguments[0];

		// find out where access is inherited from (from direct parent or somewhere further away)
		$accessPage = $this->getAccessPage($page->parent);

		$this->log->message("added: $page->id @ $page->path (access defaults to $accessPage->id @ $accessPage->path)");
		// rebuild - just this new page actually
		$this->rebuild($page->id, $accessPage->id);
	}


	/**
	 * Page moved, rebuild starting from moved page.
	 *
	 */
	public function moved($event) {

		$page = $event->arguments[0];

		// don't mind trashed pages here
		if ($page->isTrash()) return;

		// access page is either the moved page (if manage_access has been set)
		// or the closest parent with manage_access set
		if ($page->manage_access == 1) $accessPage = $page;
		else $accessPage = $page->parent("manage_access=1");

		$this->log->message("moved $page->id");

		// rebuild from moved page, using access page retrieved above
		$this->rebuild($page->id, $accessPage->id);

	}

	public function save($event) {

		$page = $event->arguments[0];

		// If page doesn't have manage_access field at all, no need to continue
		if ( ! $page->template->hasField('manage_access')) return;

		// If page has just been added and has no id yet, no need to continue
		if ( ! $page->id) return;

		// don't mind trashed pages here
		if ($page->isTrash()) return;

		$this->log->message("saved: $page->id @ $page->path");

		// are there changes to view or edit groups?
		if ($page->isChanged('view_groups') || $page->isChanged('edit_groups')) {
			// make sure all edit groups have view access as well
			$page->view_groups->add($page->edit_groups);
		}

		// reset manage_access if no groups are defined for view nor edit
		if ( ! count($page->view_groups) && ! count($page->edit_groups)) {
			$page->manage_access = 0;
		}

		// DEBUG
		$this->log->message("view groups changed: "   . $page->isChanged('view_groups') . ", now: " . $page->view_groups);
		$this->log->message("edit groups changed: "   . $page->isChanged('edit_groups') . ", now: " . $page->edit_groups);
		$this->log->message("manage access changed: " . $page->isChanged('manage_access') . ", now: " . $page->manage_access);

		$rebuildNeeded = false;

		// has page been just published? If so, a rebuild is needed
		if ($page->isChanged('status') && ! $page->is(Page::statusUnpublished)) $rebuildNeeded = true;

		// has access management been toggled? If so, a rebuild is needed
		if ($page->isChanged('manage_access')) $rebuildNeeded = true;

		if ( ! $rebuildNeeded) return;

		// manage access here
		if ($page->manage_access == 1) {
			$accessPage = $page;
			// TODO: what is this for? seems like it's not needed!
			// $page->setTrackChanges();
		// inherit access
		} else {
			$accessPage = $page->parent("manage_access=1");
			$page->inherit_access = $accessPage;
		}

		if ( ! $accessPage->id) $accessPage = $this->pages->get(1);

		$this->log->message("Access changed: $page->id => $accessPage->id");

		$this->rebuild($page->id, $accessPage->id);

	}

	/**
	 * Rebuild table field_inherit_access.
	 *
	 * Writes a row for each page inheriting access from up above.
	 * Does *not* write a row for a page managing access itself. (<-- to avoid circular references later on!)
	 *
	*/
	public function rebuild($parent_id = 1, $access_page_id = 1, $rebuild_all = false) {

 		$this->log->message("rebuild($parent_id: '" . $this->pages->get($parent_id)->path ."', $access_page_id: '" . $this->pages->get($access_page_id)->path . "')");
 		$insertions = array();
 		$deletions = array();
		$parent_id = (int) $parent_id;
		$access_page_id = (int) $access_page_id;

		if ($parent_id == 0) throw new WireException("Invalid parent id");
		if ($access_page_id == 0) throw new WireException("At least homepage should manage access");

		// Not sure if this is required here..?
		if ($parent_id == 1) {
			// if we're going to be rebuilding the entire tree, then just delete all of them now
			$this->db->query("DELETE FROM field_inherit_access"); // QA
		}

		$sql =  "SELECT pages.id, count(children.id) AS numChildren " .
				"FROM pages " .
				"LEFT JOIN pages AS children ON children.parent_id=pages.id " .
				"WHERE pages.parent_id=$parent_id " .
				"GROUP BY pages.id ";

		$result = $this->db->query($sql); // QA

		// make sure there is no row for pages managing access themselves,
		// but there is one for pages inheriting access
		if($parent_id == $access_page_id) $deletions[] = $parent_id;
		else $insertions[$parent_id] = $access_page_id;

		while ($row = $result->fetch_row()) {

			list($id, $numChildren) = $row;

			// Skip the admin alltogether
			if ($id == $this->config->adminRootPageID) continue;
			// ...and the same goes for trash
			if ($id == $this->config->trashPageID) continue;

			// Look if page manages access, if so, then skip
			$sql2 = "SELECT data FROM field_manage_access WHERE pages_id = '$id'";

			$result2 = $this->db->query($sql2);

			if ($result2->num_rows > 0) {
				if($numChildren) $this->rebuild($id, $id);
			} else {
				$insertions[$id] = $access_page_id;
				// if there are children, rebuild any of them with this access template where applicable
				if ($numChildren) {
					$this->rebuild($id, $access_page_id);
				}
			}

			$result2->free();

		}

		$result->free();

		if (count($insertions)) {
			// add the entries to the pages_access table
			$sql = "INSERT INTO field_inherit_access (pages_id, data) VALUES ";
			foreach ($insertions as $id => $access_page_id) {
				$id = (int) $id;
				$access_page_id = (int) $access_page_id;
				$sql .= "($id, $access_page_id),";
			}
			$sql = rtrim($sql, ",") . " " . "ON DUPLICATE KEY UPDATE data=VALUES(data) ";
			$this->log->message($sql);
			$this->db->query($sql); // QA

		}

		if (count($deletions)) {
			$sql = "DELETE FROM field_inherit_access WHERE pages_id IN(" . implode(',', $deletions) . ")";
			$this->log->message($sql);
			$this->db->query($sql);
		}

	}

	public function allowedTemplates($event) {
		$event->replace = true;
		$templates = array();

		if (isset($_POST['parent_id'])) {
			$parent_id = (int) $_POST['parent_id'];
		} else {
			$parent_id = isset($_GET['parent_id']) ? (int) $_GET['parent_id'] : 1;
		}

		$parent = $this->pages->get($parent_id);

		if ( ! $parent->editable()) throw new WireException("No hope dude");

		foreach ($this->templates as $t) {

			if ($t->noParents) continue;

			//if($t->useRoles && !$user->hasPermission('page-create', $t)) continue;
			//if(!$t->useRoles && !$parentEditable) continue;
			//if(!$t->useRoles && !$user->hasPermission('page-create', $this->parent)) continue;

			if (count($parent->template->childTemplates)) {
				if ( ! in_array($t->id, $parent->template->childTemplates)) continue;
			}

			if (count($t->parentTemplates)) {
				if ( ! in_array($parent->template->id, $t->parentTemplates)) continue;
			}

			if ($t->name == 'user-group') continue;

			if ($t->flags & Template::flagSystem) {
				if ($t->name == 'user' && $parent->id != $this->config->usersPageID) continue;
				if ($t->name == 'role' && $parent->id != $this->config->rolesPageID) continue;
				if ($t->name == 'permission' && $parent->id != $this->config->permissionsPageID) continue;
			}

			$templates[$t->id] = $t;
		}

		$event->return = $templates;
	}

	public function find($event) {

		$user = wire('user');
		$page = wire('page');

		if ( ! isset($page)) return;

		if ($page->template->name == "admin") return;

		if ( ! $user->user_groups) return;

		$options = $event->arguments(1);

		if (isset($options['findOne'])) {
			if ($options['findOne']) return;
		}

		$selector = $event->arguments[0];

		// get by id, skip always
		if (is_numeric($selector)) return;

		if ($user->isLoggedIn()) $user->user_groups->add($this->groupLoggedIn);

		$selector = $selector . ", view_groups|inherit_access.view_groups={$user->user_groups}";
		$event->arguments(0, $selector);
	}

	public function viewable($event) {
		// get the vars we need to check access
		$page = $event->object;
		$user = $this->user;

		// no need to check anything if it's the superuser
		if ($user->isSuperuser()) return;

		// don't allow this access control on system templates
		if ($page->template->flags & Template::flagSystem) return;

		if ($page->is(Page::statusUnpublished)) return;

		$accessPage = $this->getAccessPage($page);

		// If our view_groups have "everyone", then no need for look further
		if ($accessPage->view_groups->has($this->groupEveryone)) {
			$event->return = true;
			return;
		}

		// If user is logged in and logged group is selected, then no need for look further
		if ($user->isLoggedIn()) {
			if ($accessPage->view_groups->has($this->groupLoggedIn)) {
				$event->return = true;
				return;
			}
		}

		// If we haven't figured the view access yet, then just loop all the groups and look for our hero
		foreach ($accessPage->view_groups as $group) {
			if ($user->user_groups->has($group)) {
				$event->return = true;
				return;
			}
		}

		// Better luck next time, buddy
		$event->return = false;
	}

	public function editable($event) {
		$page = $event->object;
		$user = wire('user');

		$result = false;

		if ($user->isSuperuser()) {
			$event->return = true;
			return;
		}

		foreach ($user->user_groups as $g) {
			if ($this->getAccessPage($page)->edit_groups->has($g)) $result = true;
		}

		$event->return = $result;

	}

	// If page is editable, it is also moveable
	public function moveable($event) {
		$page = $event->object;
		$user = wire('user');

		if ($page->editable()) $event->return = true;
		else $event->return = false;
	}

	public function addable($event) {
		$page = $event->object;
		$user = wire('user');

		if ($page->editable()) $event->return = true;
		else $event->return = false;
	}

	public function sortable($event) {

		$page = $event->object;
		$user = wire('user');

		if ($page->parent->editable()) $event->return = true;
		else $event->return = false;
	}

#	public function users($event) {
#		$page = $event->object;
#		if ($page->template != "user-group") return;
#
#		$users = wire('users')->find("roles={$page->roles}");
#		$users->import($page->direct_users);
#
#		$event->return = $users;
#	}

	/**
	 * Get the Page defining access to the given page.
	 *
	 * If page manages access definitions itself, return the same page.
	 * If page inherits access definitions, return the defining page.
	 *
	 * @param Page $page
	 *
	 * @return Page
	*/
	public function getAccessPage($page) {
		if($page->manage_access) return $page;
		return $page->inherit_access;
	}

	public function whoCanAccessInfo($event) {

		$wrapper = $this->modules->get("InputfieldFieldset");
		$wrapper->label = $this->_("User Access");

		if (isset($_POST['id'])) $id = (int) $_POST['id'];
		else if (isset($_GET['id'])) $id = (int) $_GET['id'];

		$page = wire('pages')->get($id);

		if( ! $page->id) return;
		if ($page->is(Page::statusSystem)) return;
		if ($page->template->name == "admin") return;

		$accessPage = $this->getAccessPage($page);

		$viewable = $this->modules->get("InputfieldFieldset");
		$viewable->label = $this->_("Page is viewable for these groups");
		$viewable->columnWidth = 50;

		$editable = $this->modules->get("InputfieldFieldset");
		$editable->label = $this->_("Page is editable for these groups");
		$editable->columnWidth = 50;

		$pug = $this->modules->getModuleID('ProcessUserGroups');
		$ugp = wire('pages')->get("template=admin, process=$pug");

		$field = $this->modules->get("InputfieldMarkup");
		$out = "";
		foreach ($accessPage->view_groups as $g) {
			$out .= "<a class='modal' href='{$ugp->url}edit/?group_id={$g->id}&modal=1'>$g->title</a>, ";
		}

		$out = rtrim($out, " ,");
		$field->value = $out;
		$viewable->add($field);

		$field = $this->modules->get("InputfieldMarkup");
		$out = "";
		foreach ($accessPage->edit_groups as $g) {
			$out .= "<a class='modal' href='{$ugp->url}edit/?group_id={$g->id}&modal=1'>$g->title</a>, ";
		}
		$out = rtrim($out, " ,");
		$field->value = $out;
		$editable->add($field);

		$wrapper->add($viewable);
		$wrapper->add($editable);

		if($accessPage->id != $page->id) {
			$wrapper->notes = $this->_("These rules are inherited from page **") . $accessPage->title . "** (" . $accessPage->url . ")";
		} else {
			$wrapper->notes = $this->_("These rules have been defined on this very page.");
		}
		$event->return = $wrapper;

	}

	public function install() {
		$this->rebuild();
	}

}
